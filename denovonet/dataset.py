'''
dataset.py

Copyright (c) 2021 Karolis Sablauskas
Copyright (c) 2021 Gelana Khazeeva

This file is part of DeNovoCNN.

DeNovoCNN is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

DeNovoCNN is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Foobar.  If not, see <https://www.gnu.org/licenses/>.
'''

import numpy as np
import pandas as pd
import cv2
import os

from denovonet.settings import IMAGE_HEIGHT, IMAGE_WIDTH, IMAGE_CHANNELS, NUCLEOTIDES

from denovonet.variants import SingleVariant, TrioVariant
from denovonet.encoders import VariantInheritance

class Dataset():

    """
    Generates training dataset based on a list of variants in a TSV file
    
    """
    
    def __init__(self, variants_path, train_val, REFERENCE_GENOME):
        """
        variants_path : str
            path to file containing a list of DNMs
        train_val : str
            tag whether the dataset is 'train' or 'val'
        REFERENCE_GENOME: pysam.FastaFile
            reference genome FastaFile object          
        """
        self.variants_path = variants_path
        self.train_val = train_val
        self.REFERENCE_GENOME = REFERENCE_GENOME

        # load data
        self.variants_dataframe = pd.read_csv(self.variants_path, sep='\t')
        self.variants_dataframe = self.variants_dataframe[['Child',
            'Father',
            'Mother',
            'Chromosome',
            'Start position',
            'End position',
            'De novo assessment',
            'Reference',
            'Variant',
            'Child_BAM',
            'Father_BAM',
            'Mother_BAM'
        ]].fillna('')
        
        self.variants_array = np.array(self.variants_dataframe)

        self.number_variants = len(self.variants_array)
        
        # training dataset generation
        self.x, self.y, self.image_names = self.populate(self.variants_dataframe)


    def get_placeholders(self, number_variants):
        """
            Returns placeholders filled with 0s for (image, label) pair.
        """
        x = np.zeros((number_variants, IMAGE_HEIGHT, IMAGE_WIDTH, 3))
        y = np.zeros((number_variants))
        
        return x, y

    def get_image(self, chromosome, start, end, child_bam, father_bam, mother_bam):
        """
            Returns RGB image for trio (child_bam, father_bam, mother_bam) in the 
            location (chromosome, start, end).
        """
        
        child_variant = SingleVariant(chromosome, start, end, child_bam, self.REFERENCE_GENOME)
        father_variant = SingleVariant(chromosome, start, end,father_bam, self.REFERENCE_GENOME)
        mother_variant = SingleVariant(chromosome, start, end, mother_bam, self.REFERENCE_GENOME)

        trio_variant = TrioVariant(child_variant, father_variant, mother_variant)

        return trio_variant.image

    def get_label(self, assessment):
        """
            Returns label based on the assessment value, 
            generated by our in-house DNM calling tool.
        """
        
        if  assessment in ['MATERNAL','MATERNAL - LOW COVERAGE','MATERNAL - NO EXACT MATCH',
                           'MV', 'PATERNAL','PATERNAL - LOW COVERAGE', 'PV', 
                           'PV MV','SHARED','SHARED - LOW COVERAGE']:
            label = VariantInheritance.IV
        elif assessment == 'DNM':
            label = VariantInheritance.DNM
        else:
            raise('Unknown variant assessment {} {} {} {}'.format(assessment))

        return label
    
    def get_image_name(self, child_id, chromosome, start, reference):
        """
            Returns image name for saving based on child ID and variant position.
        """
        
        image_name = str(child_id) + '_' + str(chromosome) + '_' + str(start) + '_' + str(reference)
        
        return image_name

    def populate(self, cases_dataframe):
        
        """
            Returns training dataset trio: 
            (RGB images array, labels list, image filenames for saving list).
            Iterates over all the variants to generate RGB image, label and image filename.
        """
        
        # Iterate through variants and add them to placeholder
        
        case_array = np.array(cases_dataframe)
        number_variants = len(cases_dataframe)
        x, y = self.get_placeholders(number_variants)
        image_names = []

        for index, row in enumerate(case_array):

            # First three columns for family IDs
            child_id, father_id, mother_id = row[0], row[1], row[2]
            chromosome, start, end = row[3], row[4], row[5]
            assessment, reference_allele, variant_allele = row[6], row[7], row[8]
            # Get bam paths
            child_bam, father_bam, mother_bam = row[9], row[10], row[11]

            # Adjust end coordinates for pysam
            end += 1

            # Get image and labels
            image = self.get_image(chromosome, start, end, child_bam, father_bam, mother_bam)
            label = self.get_label(assessment)

            # Populate entry
            x[index] = image
            y[index] = label
            image_names.append(self.get_image_name(child_id, chromosome, start, reference_allele))

            print('Loading variant {} : {} , value {}. {}:{}-{} {} {}'.format(
                index, assessment, label, chromosome, start, end, reference_allele, variant_allele))
        
        image_names = np.array(image_names)
        
        # shuffle dataset
        shuffled_x, shuffled_y, shuffled_image_names = self.shuffle(x, y, image_names)

        return shuffled_x, shuffled_y, shuffled_image_names

    @staticmethod
    def shuffle(x, y, image_names):
        """
            Returns shuffled training dataset
        """
        
        randomize = np.arange(len(x))
        np.random.shuffle(randomize)
        
        shuffled_x = x[randomize].copy()
        shuffled_y = y[randomize].copy()
        shuffled_image_names = image_names[randomize].copy()

        return shuffled_x, shuffled_y, shuffled_image_names
    

    def save_images(self, IMAGES_FOLDER, DATASET_NAME):
        """
            Saves training dataset images to a following folder structure:
                {IMAGES_FOLDER}/{DATASET_NAME}/{train_val}/dnm/ or
                {IMAGES_FOLDER}/{DATASET_NAME}/{train_val}/iv/
        """
        train_val = self.train_val
        x_data = self.x
        y_data = self.y

        for index, image in enumerate(x_data):
            label = y_data[index]
            if label == VariantInheritance.IV:
                save_path = os.path.join(IMAGES_FOLDER, DATASET_NAME, train_val, 'iv')
            elif label == VariantInheritance.DNM:
                save_path = os.path.join(IMAGES_FOLDER, DATASET_NAME, train_val, 'dnm')
            else:
                raise('Unknown label {} {} {} {}'.format(label))
            
            filename = '{}.png'.format(str(index)+'_'+self.image_names[index])
            
            # Save as RGB 
            reordered_placeholder = np.zeros((image.shape))
            reordered_placeholder[:,:,0], reordered_placeholder[:,:,1], reordered_placeholder[:,:,2] = image[:,:,2], image[:,:,1], image[:,:,0]

            output_path = os.path.join(save_path,filename)

            cv2.imwrite(output_path,reordered_placeholder)
            print('Saved {} as {}'.format(filename,output_path))
            

class CustomAugmentation(object):
    """ Defines a custom augmentation class. Randomly applies one of transformations."""
        
    def __init__(self, probability=0.9, reads_cropping = False, reads_shuffling = False, multi_nucleotide_snp=False, nucleotides_relabeling=False, channels_switching=False, seed=None):
        self.probability = probability
        self.reads_cropping = reads_cropping
        self.reads_shuffling = reads_shuffling
        self.multi_nucleotide_snp = multi_nucleotide_snp
        self.nucleotides_relabeling = nucleotides_relabeling
        self.channels_switching = channels_switching
        self.transformations = []
        
        if seed:
            np.random.seed(seed)

    def _check_augmentations(self):
        """
            Creates augmentations list.
        """
        
        self.transformations = []

        if self.reads_cropping:
            self.transformations.append(self._reads_cropping)
        if self.reads_shuffling:
            self.transformations.append(self._reads_shuffling)
        if self.multi_nucleotide_snp:
            self.transformations.append(self._multi_nucleotide_snp)
        if self.nucleotides_relabeling:
            self.transformations.append(self._nucleotides_relabeling)
        if self.channels_switching:
            self.transformations.append(self._channels_switching)

    @staticmethod
    def _reads_cropping(img):
        """
            Returns image with randomly cropped reads.
        """
        new_img = img.copy()

        nreads_c, nreads_f, nreads_m = tuple(np.sum(np.sum(new_img, axis=1) > 0., axis=0))

        nreads_c = max(5, nreads_c) 
        nreads_f = max(5, nreads_f) 
        nreads_m = max(5, nreads_m)

        nreads_c = np.random.choice(np.arange(5, nreads_c + 1))
        nreads_f = np.random.choice(np.arange(5, nreads_f + 1))
        nreads_m = np.random.choice(np.arange(5, nreads_m + 1))

        new_img[nreads_c:, :, 0] = 0.
        new_img[nreads_f:, :, 1] = 0.
        new_img[nreads_m:, :, 2] = 0.

        return new_img
    
    @staticmethod
    def _nucleotides_relabeling(img):
        """
            Returns image with nucleotides relabeled (swapped), 
            for example A->T, T->C, C->G, G->A.
        """
        new_img = img.copy()
        
        new_ordering = list(range(NUCLEOTIDES))
        np.random.shuffle(new_ordering)
        
        for old_idx, new_idx in enumerate(new_ordering):
            new_img[:, old_idx::NUCLEOTIDES, :]  = img[:, new_idx::NUCLEOTIDES, :].copy()
        return new_img
    
    
    @staticmethod
    def _multi_nucleotide_snp(img):
        """
            Returns image with added SNP to the left or
            to the right of original SNP.
        """
        def differ_array(arr):
            """
                Randomly changes original array
            """
            
            for_mask = np.sum(np.sum(arr>0, axis=2), axis=0)
            
            if np.sum(for_mask>0) == 0:
                return arr
            
            min_val = np.min(for_mask[for_mask>0])

            rand_arr = np.random.randint(-8, high=8, size=arr.shape)
            arr[arr>0] += rand_arr[arr>0]

            arr[:, for_mask > min_val, :] //= 3

            arr = np.clip(arr, 0, 255)
            return arr

        def get_rearranged_snp(snp, n=1):
            """
                Applies random nucleotides relabeling to snp to get different snp.
            """
            image_new = np.tile(snp, (1, n, 1))

            for i in range(n):
                image_new[:, i*NUCLEOTIDES:(i+1)*NUCLEOTIDES, :] = CustomAugmentation._nucleotides_relabeling(image_new[:, i*NUCLEOTIDES:(i+1)*NUCLEOTIDES, :])

            return image_new

        def insert_snp_left(image, n=1):
            """
                Insertion of the new SNP to the left.
            """
            image_new = image.copy()
            image_new[:, :(20-n)*NUCLEOTIDES, :] = image_new[:, n*NUCLEOTIDES:20*NUCLEOTIDES, :].copy()
            image_new[:, (20-n)*NUCLEOTIDES : 20*NUCLEOTIDES, :] = differ_array(get_rearranged_snp(image_new[:, 20*NUCLEOTIDES : 21*NUCLEOTIDES, :], n))
            return image_new

        def insert_snp_right(image, n=1):
            """
                Insertion of the new SNP to the right.
            """
            return insert_snp_left(image[:, ::-1, :], n)[:, ::-1, :]

        func = np.random.choice([insert_snp_left, insert_snp_right])
        n = np.random.choice(range(1, 3))

        return func(img, n)

    @staticmethod
    def _reads_shuffling(img):
        """
            Shuffling the reads order.
        """
        new_img = img.copy()

        nreads_c, nreads_f, nreads_m = tuple(np.sum(np.sum(new_img, axis=1) > 0., axis=0))

        np.random.shuffle(new_img[:nreads_c, :, 0])
        np.random.shuffle(new_img[:nreads_f, :, 1])
        np.random.shuffle(new_img[:nreads_m, :, 2])
        
        return new_img
    
    @staticmethod
    def _channels_switching(img):
        """
            Switching parental channels.
        """
        new_img = img.copy()
        new_img[:, :, 1], new_img[:, :, 2] = new_img[:, :, 2].copy(), new_img[:, :, 1].copy()
        
        return new_img

    def __call__(self, img):
        """
            Applies random augmentation from the list.
        """
        
        if img.shape[2] != 3:
            print (img.shape)
            raise Exception("Wrong image format!")
        
        random_number = np.random.random()
                
        if random_number > self.probability:
            pass
        else:
            self._check_augmentations()
            transformation = np.random.choice(self.transformations)

            return transformation(img)
           
                
        return img